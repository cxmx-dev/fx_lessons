<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Fullscreen 3D Scene</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        canvas { display: block; }
        #loading { 
            position: fixed; 
            top: 50%; 
            left: 50%; 
            transform: translate(-50%, -50%); 
            color: white; 
            font-family: Arial, sans-serif; 
            font-size: 18px; 
        }
    </style>
</head>
<body>
    <div id="loading">Loading 3D Scene...</div>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.158.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.158.0/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { SSAOPass } from 'three/addons/postprocessing/SSAOPass.js';

        console.log('Three.js version:', THREE.REVISION);
        console.log('Starting 3D scene...');

        // Global variables
        let scene, camera, renderer, composer, controls, ssaoPass;
        let mesh, wireframe, particles, particlesGeometry, wavePhases;
        let time = 0;

        // Simple fallback scene
        function createFallbackScene() {
            console.log('Creating fallback scene...');
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 5;
            const renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            
            const geometry = new THREE.BoxGeometry();
            const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
            const cube = new THREE.Mesh(geometry, material);
            scene.add(cube);
            
            function animate() {
                requestAnimationFrame(animate);
                cube.rotation.x += 0.01;
                cube.rotation.y += 0.01;
                renderer.render(scene, camera);
            }
            animate();
            document.getElementById('loading').style.display = 'none';
        }

        // Initialize the scene
        function initScene() {
            try {
                // Scene setup
                scene = new THREE.Scene();
                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.set(0, 3, 10);
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                document.body.appendChild(renderer.domElement);
                console.log('Scene setup completed');

                // Post-processing setup
                try {
                    composer = new EffectComposer(renderer);
                    const renderPass = new RenderPass(scene, camera);
                    composer.addPass(renderPass);
                    ssaoPass = new SSAOPass(scene, camera, window.innerWidth, window.innerHeight);
                    ssaoPass.kernelRadius = 32;
                    ssaoPass.kernelSize = 32;
                    ssaoPass.minDistance = 0.0001;
                    ssaoPass.maxDistance = 0.02;
                    ssaoPass.output = SSAOPass.OUTPUT.Default;
                    composer.addPass(ssaoPass);
                    console.log('Post-processing setup completed');
                } catch (error) {
                    console.error('Post-processing setup failed:', error);
                    composer = null;
                    ssaoPass = null;
                }

                // Create mesh
                const detail = 5;
                const geometry = new THREE.IcosahedronGeometry(1.5, detail);
                const positions = geometry.attributes.position;
                for (let i = 0; i < positions.count; i++) {
                    const v = new THREE.Vector3().fromBufferAttribute(positions, i);
                    const noise = (Math.sin(v.x * 10) + Math.cos(v.y * 10) + Math.sin(v.z * 10)) * 0.1;
                    v.normalize().multiplyScalar(1.5 + noise);
                    positions.setXYZ(i, v.x, v.y, v.z);
                }
                geometry.computeVertexNormals();
                const material = new THREE.MeshStandardMaterial({ color: 0x00ff88, roughness: 0.8, metalness: 0.2 });
                mesh = new THREE.Mesh(geometry, material);
                scene.add(mesh);

                // Wireframe overlay
                const wireframeGeometry = new THREE.EdgesGeometry(geometry);
                const wireframeMaterial = new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2 });
                wireframe = new THREE.LineSegments(wireframeGeometry, wireframeMaterial);
                scene.add(wireframe);

                // Particle wave
                const particleCount = 1200;
                particlesGeometry = new THREE.BufferGeometry();
                const particlePositions = new Float32Array(particleCount * 3);
                wavePhases = new Float32Array(particleCount);
                for (let i = 0; i < particleCount; i++) {
                    const x = (i % 40 - 20) * 0.3;
                    const z = (Math.floor(i / 40) - 15) * 0.3;
                    particlePositions[i * 3] = x;
                    particlePositions[i * 3 + 1] = 0;
                    particlePositions[i * 3 + 2] = z;
                    wavePhases[i] = Math.random() * Math.PI * 2;
                }
                particlesGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
                const particleMaterial = new THREE.PointsMaterial({ color: 0xff0077, size: 0.05 });
                particles = new THREE.Points(particlesGeometry, particleMaterial);
                scene.add(particles);

                // Lighting
                const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
                scene.add(ambientLight);
                const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
                directionalLight.position.set(4, 5, 4);
                scene.add(directionalLight);

                // Controls
                try {
                    controls = new OrbitControls(camera, renderer.domElement);
                    controls.enableDamping = true;
                    controls.dampingFactor = 0.1;
                    console.log('Controls setup completed');
                } catch (error) {
                    console.error('Controls setup failed:', error);
                    controls = null;
                }

                // Input handling
                setupInputs();

                // Resize handling
                window.addEventListener('resize', onWindowResize);

                // Start animation
                animate();
                document.getElementById('loading').style.display = 'none';
                console.log('Scene initialized successfully');

            } catch (error) {
                console.error('Scene initialization failed:', error);
                createFallbackScene();
            }
        }

        // Input setup
        function setupInputs() {
            const inputs = {
                keyboard: { move: { x: 0, z: 0 }, rotate: { x: 0, y: 0 } },
                gamepad: { connected: false, axes: [0, 0, 0, 0], buttons: [] },
                microphone: { amplitude: 0 }
            };

            // Keyboard input
            document.addEventListener('keydown', (e) => {
                switch (e.code) {
                    case 'KeyW': inputs.keyboard.move.z = -1; break;
                    case 'KeyS': inputs.keyboard.move.z = 1; break;
                    case 'KeyA': inputs.keyboard.move.x = -1; break;
                    case 'KeyD': inputs.keyboard.move.x = 1; break;
                    case 'ArrowUp': inputs.keyboard.rotate.x = -1; break;
                    case 'ArrowDown': inputs.keyboard.rotate.x = 1; break;
                    case 'ArrowLeft': inputs.keyboard.rotate.y = -1; break;
                    case 'ArrowRight': inputs.keyboard.rotate.y = 1; break;
                }
            });

            document.addEventListener('keyup', (e) => {
                switch (e.code) {
                    case 'KeyW': case 'KeyS': inputs.keyboard.move.z = 0; break;
                    case 'KeyA': case 'KeyD': inputs.keyboard.move.x = 0; break;
                    case 'ArrowUp': case 'ArrowDown': inputs.keyboard.rotate.x = 0; break;
                    case 'ArrowLeft': case 'ArrowRight': inputs.keyboard.rotate.y = 0; break;
                }
            });

            // Gamepad input
            window.addEventListener('gamepadconnected', (e) => {
                inputs.gamepad.connected = true;
                console.log('Gamepad connected:', e.gamepad.id);
            });

            window.addEventListener('gamepaddisconnected', () => {
                inputs.gamepad.connected = false;
                console.log('Gamepad disconnected');
            });

            // Store inputs globally for animation loop
            window.inputs = inputs;
        }

        // Resize handler
        function onWindowResize() {
            if (camera && renderer) {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                if (composer) composer.setSize(window.innerWidth, window.innerHeight);
                if (ssaoPass) ssaoPass.setSize(window.innerWidth, window.innerHeight);
            }
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            time += 0.02;

            try {
                // Update gamepad
                if (window.inputs && window.inputs.gamepad.connected) {
                    const gamepad = navigator.getGamepads()[0];
                    if (gamepad) {
                        window.inputs.gamepad.axes = gamepad.axes;
                        window.inputs.gamepad.buttons = gamepad.buttons;
                    }
                }

                // Mesh and wireframe animation
                if (mesh && wireframe) {
                    const inputs = window.inputs || { keyboard: { rotate: { x: 0, y: 0 } }, gamepad: { axes: [0, 0, 0, 0] } };
                    mesh.rotation.x += (inputs.keyboard.rotate.x + inputs.gamepad.axes[3]) * 0.05;
                    mesh.rotation.y += (inputs.keyboard.rotate.y + inputs.gamepad.axes[2]) * 0.05;
                    wireframe.rotation.copy(mesh.rotation);
                    mesh.scale.setScalar(1 + Math.cos(time * 2) * 0.1);
                    wireframe.scale.copy(mesh.scale);
                }

                // Camera movement
                if (camera) {
                    const inputs = window.inputs || { keyboard: { move: { x: 0, z: 0 } }, gamepad: { axes: [0, 0, 0, 0] } };
                    const moveSpeed = 0.15;
                    camera.position.x += (inputs.keyboard.move.x + inputs.gamepad.axes[0]) * moveSpeed;
                    camera.position.z += (inputs.keyboard.move.z + inputs.gamepad.axes[1]) * moveSpeed;
                }

                // Particle wave animation
                if (particlesGeometry && wavePhases) {
                    const particlePositions = particlesGeometry.attributes.position.array;
                    const particleCount = wavePhases.length;
                    const inputs = window.inputs || { microphone: { amplitude: 0 } };
                    
                    for (let i = 0; i < particleCount; i++) {
                        const x = particlePositions[i * 3];
                        const z = particlePositions[i * 3 + 2];
                        const wave = Math.sin(time + x * 0.5 + z * 0.5 + wavePhases[i]) * (0.5 + inputs.microphone.amplitude);
                        particlePositions[i * 3 + 1] = wave;
                    }
                    particlesGeometry.attributes.position.needsUpdate = true;
                }

            } catch (error) {
                console.error('Animation error:', error);
            }

            // Render
            if (controls) controls.update();
            if (composer) {
                composer.render();
            } else if (renderer && scene && camera) {
                renderer.render(scene, camera);
            }
        }

        // Disable right-click context menu
        document.addEventListener('contextmenu', (e) => e.preventDefault());

        // Initialize the scene
        initScene();

    </script>
</body>
</html>